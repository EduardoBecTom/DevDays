# Tareas entregable nivel 1

## N1-1 Función recursiva: paginación de datos de la API de GitHub.

Esta función recursiva genérica ha ubicado en el archivo `github.services.js`, en ella se sigue la documentación de github para la cabecera, añadiendo la posibilidad de autenticación para poder tener 5000 peticiones por hora en lugar de 60 si no se está autenticado.

Para almacenar toda la información a través de las distintas llamadas a la función se ha diseñado una memoria local la cual asciende a través de las llamadas.

Para detectar el enlace de la siguiente página, se busca una coincidencia con un enlace entre signos `<` y `>`, y posteriormente `rel="next"`

```
import axios from 'axios';

const headers = {
    'Accept': 'application/vnd.github.v3+json'
};

if (process.env.GITHUB_TOKEN) {
    headers['Authorization'] = `token ${process.env.GITHUB_TOKEN}`;
}

const githubClient = axios.create({
    baseURL: 'https://api.github.com',
    headers: headers
});


export const fetchAllPages = async (url, accumulatedData = []) => {
    try {
        const response = await githubClient.get(url);
        const newData = accumulatedData.concat(response.data);
        const linkHeader = response.headers.link;
        const nextMatch = linkHeader?.match(/<([^>]+)>;\s*rel="next"/);
        const nextUrl = nextMatch ? nextMatch[1] : null;

        if (nextUrl) {
            return await fetchAllPages(nextUrl, newData);
        }

        return newData;

    } catch (error) {
        console.error(`Error consultando GitHub (${url}):`, error.message);
        throw error;
    }
};
```
## N1-2 Creación de métricas personalizadas

Un aspecto importante es la monitorización de los recursos utilizados por nuestros procesos, para monitorizar la cantidad de memoria RAM utilizada por nuestro proceso Node.js, se ha utilizado la función `process.memoryUsage()`, y se ha escogido la variable `heapUsed`, como este valor no va siempre en aumento si no que va variando, se ha creado un instrumento de tipo `Gauge`.
Además se ha almacenado en un Meter distinto para una mayor claridad de los datos posteriormente, ya que no tiene relación con los Meter creados hasta el momento.

```
const systemMeter = metrics.getMeter('system-monitor');

const ramGauge = systemMeter.createObservableGauge('process_ram_usage', {
    description: 'Memoria RAM utilizada por el proceso de Node.js',
    unit: 'MB',
});

ramGauge.addCallback((result) => {
    const memoryInBytes = process.memoryUsage().heapUsed;
    const memoryInMB = memoryInBytes / 1024 / 1024;
    
    result.observe(memoryInMB);
});
```

